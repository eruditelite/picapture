#!/usr/bin/env python3

################################################################################
## picapture.py
################################################################################

__author__ = "John Jacques"
__version__ = __VERSION__
__license__ = 'MIT'

import argparse
import logging
import numpy as np
import numpy
import os
import pickle
import PIL
import re
import select
import socketserver
import statistics
import sys
import tempfile
import termplotlib
import threading
import time
import zwoasi

from controls import Controls
from datetime import datetime
from http import server
from io import BytesIO
from math import log2, pow
## NOTE: PIL is really Pillow...
from PIL import Image, ImageDraw, ImageFont, ImageStat
from queue import Queue
from threading import Condition, Thread
from time import sleep, time

################################################################################
## Functions for Modular Use
################################################################################

def script_info():
    print("--> " + os.path.basename(__file__) +
          " version is {:s}".format(__version__))
    if os.path.isfile("/etc/os-release"):
        osrf = open("/etc/os-release", "rt")
        distribution = re.search("NAME=(.*)", osrf.read()).group(1)[1:-1]
        osrf.seek(0)
        version = re.search("VERSION_ID=(.*)", osrf.read()).group(1)[1:-1]
        osrf.close()
        print("--> running on " + distribution + ":" + version)
    else:
        print("--> running on something unknown (TODO: find out)")

def save_capture(camera, filename):
    controls = camera.get_controls()
    camera.set_control_value(zwoasi.ASI_BANDWIDTHOVERLOAD,
                             controls['BandWidth']['MinValue'])
    camera.disable_dark_subtract()
    camera.stop_video_capture()
    camera.stop_exposure()
    camera.set_image_type(zwoasi.ASI_IMG_RGB24)
    camera.capture(filename=filename)

def setup_capture(camera):
    controls = camera.get_controls()
    camera.set_control_value(zwoasi.ASI_BANDWIDTHOVERLOAD,
                             controls['BandWidth']['MinValue'])
    camera.disable_dark_subtract()
    camera.stop_video_capture()
    camera.stop_exposure()
    camera.set_image_type(zwoasi.ASI_IMG_RGB24)
    ## Without this, camera.capture() can throw an exception!
    ## After the sleep, all captures work...
    sleep(1)

def to_image(camera, raw, stats=False, hist=False):
    logging.debug(f"display_exposure({camera}, {raw}, {stats}, {hist}")
    roi = camera.get_roi_format()
    mode = None

    if len(raw.shape) == 3:
        raw = raw[:, :, ::-1]   # convert bgr to rgb
    if roi[3] == zwoasi.ASI_IMG_RAW16:
        mode = 'I;16'

    image = PIL.Image.fromarray(raw, mode=mode)
    histogram = image.histogram()
    histR = histogram[0:255]
    histG = histogram[256:511]
    histB = histogram[512:767]
    median_histogram = statistics.median(histogram)

    if hist:
        x = list(range(0, 255))
        figure = termplotlib.figure()
        figure.plot(x, histR, label="histR")
        figure.plot(x, histG, label="histG")
        figure.plot(x, histB, label="histB")
        figure.show()

    if stats:
        medR = statistics.median(histR)
        medG = statistics.median(histG)
        medB = statistics.median(histB)
        print(f"median of the histograms {medR}/{medG}/{medB}")
        median_image = numpy.median(raw)
        print(f"median of the image is {median_image}")

    return image

class StreamingOutput(object):
    def __init__(self):
        self.frame = None
        self.buffer = BytesIO()
        self.condition = Condition()

    def write(self, buf):
        if buf.startswith(b'\xff\xd8'):
            # New frame, copy the existing buffer's content and notify all
            # clients it's available
            self.buffer.truncate()
            with self.condition:
                self.frame = self.buffer.getvalue()
                print("Notifying All Clients!")
                self.condition.notify_all()
            self.buffer.seek(0)
        return self.buffer.write(buf)

class StreamingServer(socketserver.ThreadingMixIn, server.HTTPServer):
    allow_reuse_address = True
    daemon_threads = True

    def __init__(self, address, handler, output_stream):
        super(StreamingServer, self).__init__(address, handler)
        self.output_stream = output_stream
        # Used for invokers to know the camera has stopped responding
        self.last_update_timestamp = time()

class StreamingHandler(server.BaseHTTPRequestHandler):
    def do_GET(self):
        if self.path == '/':
            self.send_response(301)
            self.send_header('Location', '/stream.mjpg')
            self.end_headers()
        elif self.path == '/stream.mjpg':
            self.send_response(200)
            self.send_header('Age', 0)
            self.send_header('Cache-Control', 'no-cache, private')
            self.send_header('Pragma', 'no-cache')
            self.send_header('Content-Type',
                             'multipart/x-mixed-replace; boundary=FRAME')
            self.end_headers()
            try:
                while True:
                    with self.server.output_stream.condition:
                        self.server.output_stream.condition.wait()
                        frame = self.server.output_stream.frame
                    print("Awake!")
                    self.wfile.write(b'--FRAME\r\n')
                    self.send_header('Content-Type', 'image/jpeg')
                    self.send_header('Content-Length', len(frame))
                    self.end_headers()
                    self.wfile.write(frame)
                    self.wfile.write(b'\r\n')
            except Exception as e:
                logging.warning(
                    'Removed streaming client %s: %s',
                    self.client_address, str(e))
        else:
            self.send_error(404)
            self.end_headers()

class AutoExposurer:
    def __init__(self, maxGain, maxExp):
        self.maxGain = maxGain
        self.maxExp = maxExp
        self.skipFrames = 0  # Introduce some latency in exposure adjustment
        self.gainStep = 50 if maxGain > 400 else 10
        self.targetBrightnessLow = 100
        self.targetBrightnessHigh = 160
        self.targetBrightness = (self.targetBrightnessHigh + self.targetBrightnessLow) / 2

    # Returns (changed, newGain, newExp, med)
    def adjustExp(self, gain, exp, img):
        if self.skipFrames > 0:
            self.skipFrames -= 1
            return (False, None, None, 100)
        med = np.median(img)
        if self.targetBrightnessLow < med < self.targetBrightnessHigh:
            return (False, None, None, med)
        # Need to adjust exposure. Add a latency to give the camera some responding time.
        self.skipFrames = 2
        if med > self.targetBrightnessHigh:
            ratio = med / self.targetBrightness # > 1.0
            # Need to reduce exposure. Reduce gain if possible.
            gainDelta = self.gainStep * log2(ratio)
            if gain >= gainDelta:
                return (True, int(gain - gainDelta), int(exp), med)
            gainDeltaFulfilled = pow(2, gain)
            exposureDelta = ratio / gainDeltaFulfilled
            # We don't have a min epxosure
            return (True, 0, int(exp / exposureDelta), med)
        if med < self.targetBrightnessLow:
            ratio = self.targetBrightness / med
            # Need to bump exposure. Increase exposure if possible
            if exp * ratio < self.maxExp:
                return (True, gain, int(exp * ratio), med)
            expDeltaFulfilled = self.maxExp / exp
            gainDelta = self.gainStep * log2(ratio / expDeltaFulfilled)
            newGain = min(self.maxGain, gainDelta + gain)
            return (True, int(newGain), int(self.maxExp), med)

class ZWOCamera(Thread):
    def __init__(self, output_stream, interval=0):
        super(ZWOCamera, self).__init__()
        self.terminate = False
        self.interval = interval
        self.last_gain = 0
        self.last_exposure = 0
        # Optional hook for updating the watchdog, which monitors when
        # the last frame was updated
        self.server = None
        self.continuousFailureCount = 0
        self.maxContinuousFailureCount = 5
        self.initialize_camera()

        # auto stretch
        self.auto_stretch = True
        self.auto_stretch_threshold = 40
        self.auto_stretch_target = 150

        print('Camera initialization complete.')
        self.stream = output_stream
        self.start()

    def initialize_camera(self):
        print('Initializing camera...')
        sleep(2)
        num_cameras = zwoasi.get_num_cameras()
        if num_cameras == 0:
            raise RuntimeError('No ZWO camera was detected.')
        try:
            cameras_found = zwoasi.list_cameras()
            self.camera = zwoasi.Camera(0)
        except Exception as e:
            print("Exception: " + str(e))
            sys.exit(1)

        # Uncomment to use binning
        #self.camera.set_roi(bins=4)
        camera_info = self.camera.get_camera_property()
        print(camera_info)
        controls = self.camera.get_controls()
        print(controls)

        self.camera.set_image_type(zwoasi.ASI_IMG_RGB24)

        self.camera.set_control_value(zwoasi.ASI_BANDWIDTHOVERLOAD, 
                                      self.camera.get_controls()['BandWidth']['DefaultValue'],
                                      auto=True)

        # Set auto exposure value
        self.whbi = self.camera.get_roi_format()
        self.camera.auto_wb()
        # Uncomment to enable manual white balance
        # self.camera.set_control_value(zwoasi.ASI_WB_B, 99)
        # self.camera.set_control_value(zwoasi.ASI_WB_R, 75)
        # Uncomment to use stock auto exposure
        #self.useStockAutoExposure = True
        #self.camera.set_control_value(zwoasi.ASI_AUTO_MAX_GAIN, 425)
        #self.camera.set_control_value(zwoasi.ASI_AUTO_MAX_BRIGHTNESS, 130)
        #self.camera.set_control_value(controls['AutoExpMaxExpMS']['ControlType'], 3000)
        # Use our own auto exposure
        self.useStockAutoExposure = False
        maxGain = controls['Gain']['MaxValue']
        self.autoExposurer = AutoExposurer(maxGain, 500000) # us
        self.camera.set_control_value(zwoasi.ASI_EXPOSURE,
                                 1000,
                                 auto=self.useStockAutoExposure)
        self.camera.set_control_value(zwoasi.ASI_GAIN,
                                 0,
                                 auto=self.useStockAutoExposure)
        # Uncomment to enable flip
        # self.camera.set_control_value(zwoasi.ASI_FLIP, 3)
        self.camera.start_video_capture()

    def run(self):
        print('Start capturing...')
        last_timestamp = 0
        try:
            while not self.terminate:
                if time() < last_timestamp + self.interval:
                    sleep(0.1)
                    continue
                last_timestamp = time()
                settings = self.camera.get_control_values()
                self.last_gain = settings['Gain']
                self.last_exposure = settings['Exposure']
                try:
                    img = self.camera.capture_video_frame(timeout=max(5000, 500 + 10 * settings['Exposure'] / 1000))
                    if self.server is not None:
                        self.server.last_update_timestamp = time()
                except Exception as e:
                    print("Error: " + str(e))
                    self.continuousFailureCount += 1
                    if self.continuousFailureCount >= self.maxContinuousFailureCount:
                        print("Max continuous failure count reached.. About to restart in 60 seconds.")
                        sys.exit(1)
                    self.camera.stop_exposure()
                    self.camera.stop_video_capture()
                    self.camera.close()
                    self.initialize_camera()
                    # Set the exposure and gain to the last known good value to reduce the auto exposure time
                    self.camera.set_control_value(zwoasi.ASI_EXPOSURE,
                                             self.last_exposure,
                                             auto=self.useStockAutoExposure)
                    self.camera.set_control_value(zwoasi.ASI_GAIN,
                                             self.last_gain,
                                             auto=self.useStockAutoExposure)
                    continue
                self.continuousFailureCount = 0
                # Update the auto exposure
                result = self.autoExposurer.adjustExp(self.last_gain, self.last_exposure, img)
                if result is None:
                    # For unknown reason, sometimes the result would be None. Simply retry would solve the issue
                    result = self.autoExposurer.adjustExp(self.last_gain, self.last_exposure, img)
                    if result is None:
                        continue
                changed, newGain, newExp, med = result
                if changed:
                    self.camera.set_control_value(zwoasi.ASI_EXPOSURE,
                        newExp,
                        auto=self.useStockAutoExposure)
                    self.camera.set_control_value(zwoasi.ASI_GAIN,
                        newGain,
                        auto=self.useStockAutoExposure)
                    #print(f'Changed {changed} Med: {med} Gain: {newGain} Exposure: {newExp}')
#                else:
#                    print(f'Changed {changed} Med: {med} Gain: {self.last_gain} Exposure: {self.last_exposure}')

                # Check for Keyboard Input #
                ############################

                if select.select([sys.stdin], [], [], 0) == ([sys.stdin], [], []):
                    input = sys.stdin.readline()
                    print("Got " + repr(input))

                # convert the numpy array to PIL image
                mode = None
                if len(img.shape) == 3:
                    img = img[:, :, ::-1]  # Convert BGR to RGB
                if self.whbi[3] == zwoasi.ASI_IMG_RAW16:
                    mode = 'I;16'
                image = Image.fromarray(img, mode=mode)
                # If the image is too dark, auto stretch it
                stat = ImageStat.Stat(image)
                mean = stat.mean[0]
                if self.auto_stretch and mean < self.auto_stretch_threshold:
                    # apply a gamma transform
                    gamma = np.log(self.auto_stretch_target) / np.log(mean)
                    arr = np.asarray(image)
                    arr = np.minimum(255, np.power(arr, gamma)).astype('uint8')
                    image = Image.fromarray(arr, mode=image.mode)
                # Add some annotation
                draw = ImageDraw.Draw(image)
                pstring = datetime.now().strftime("%m/%d/%Y, %H:%M:%S") + f', gain {self.last_gain}, exp {self.last_exposure}'
                draw.text((15, 15), pstring, fill='white')
                # Write to the stream
                print("Writing New Image!")
                image.save(self.stream, format='jpeg', quality=90)
        finally:
            self.camera.stop_video_capture()
            self.camera.stop_exposure()

################################################################################
## Information
################################################################################

def info(camera):
    info = camera.get_camera_property()
    print('#### Info for %s ####' % (info['Name']))
    for name in info.keys():
        if name == 'Name':
            continue
        print('    %s:%s' % (name, info[name]))
    controls = Controls(camera, logging)
    controls.display()

################################################################################
## Focus
##
## The idea is to start a web server that displays the latest image
## captured (using video capture) until SIGINT.
################################################################################

def focus(camera, settings, options):
    logging.debug(f"focus({camera}, {settings}, {options})")
    stream_output = StreamingOutput()
    # Uncomment to use the proper camera
    # from RPiCamera import RPiCamera
    # thread = RPiCamera(stream_output, latest_output, logger, 0)
    thread = ZWOCamera(stream_output, 0)
    try:
        address = ('', 8000)
        server = StreamingServer(address, StreamingHandler, stream_output)
        thread.server = server
        server.serve_forever()
    finally:
        thread.terminate = True

################################################################################
## Capture
##
## NOTE: This handles the 'exposure' command as well.
################################################################################

def capture(camera, settings, options):
    info = camera.get_camera_property()
    ctrls = camera.get_controls()
    controls = Controls(camera, logging)
    logging.debug("capture(): Using %s, options are %s." %
                  (info['Name'], str(options[:])))
    controls.default()

    # Process Arguments #
    #####################
    adjust = False
    histogram = False
    it = iter(options)
    for name in it:
        value = next(it)
        logging.debug("capture(): Processing %s %s" % (name, value))
        if name == 'output':
            filename = value
        elif name == 'number':
            number = int(value);
        elif name == 'adjust' and value == "true":
            adjust = True
        elif name == 'histogram' and value == "true":
            histogram = True
        else:
            controls.set(name, int(value))

    if adjust == False:
        histogram = False

    if adjust and number != 1:
        raise ValueError("in adjust mode, number must be 1")

    controls.save(settings)

    if 'filename' not in locals() or filename == "":
        raise ValueError("output MUST be specified!")

    # Capture! #
    ############

    setup_capture(camera)

    if 'number' not in locals() or number == 1:
        raw = camera.capture()
        image = to_image(camera, raw, adjust, histogram)
        image.save(filename)
        controls.save(filename + ".info", True)
    else:
        for i in range(0, number, 1):
            name = filename.split('.')
            name = name[0] + str(i).zfill(len(str(number))) + "." + name[1]
            raw = camera.capture()
            image = to_image(camera, raw)
            image.save(name)
        name = filename.split('.')
        name = name[0] + 'N' * len(str(number)) + '.' + name[1] + '.info'
        controls.save(name, True)

################################################################################
## When used as a script...
################################################################################

def main(argv):
    # parse arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('--loglevel', help="logger level",
                        choices=['DEBUG', 'INFO', 'WARNING',
                                 'ERROR', 'CRITICAL'], type=str.upper)
    parser.add_argument("--logfile", help="file for logger output")
    parser.add_argument('-v', '--version', help="display the version",
                        action="store_true")
    parser.add_argument('-c', '--command',
                        help="Run a command: <index of camera> "
                        "[list of name=value pairs]",
                        choices = ['list', 'info', 'exposure',
                                   'focus', 'capture'],
                        default="list")
    args, unknown = parser.parse_known_args()

    # set up the logger
    if args.loglevel:
        loglevel = getattr(logging, args.loglevel)
    else:
        loglevel = logging.root.level

    logging.basicConfig(level=loglevel,
                        format='%(filename)s - %(levelname)s - %(message)s')

    if args.logfile:
        logging.getLogger().addHandler(logging.FileHandler(args.logfile))

    if args.version:
        script_info()

    asilib = os.getenv('ZWO_ASI_LIB')

    if asilib:
        zwoasi.init(asilib)
    else:
        logging.error("ZWO_ASI_LIB must be the full path to libASICamera2.so!")
        sys.exit(1)

    num_cameras = zwoasi.get_num_cameras()

    if num_cameras == 0:
        logging.error("No Cameras Found")
        sys.exit(1)
    else:
        logging.info("Cameras Found: " + str(num_cameras))

    cameras = zwoasi.list_cameras()

    if args.command == 'list':
        for i in range(num_cameras):
            print('%d : %s' % (i, cameras[i]))
        sys.exit(0)

    id = int(unknown[0])
    if id < num_cameras:
        camera = zwoasi.Camera(id)
    else:
        logging.error('Invalid Camera ID')
        sys.exit(1)

    unknown.pop(0)
    unknown = [x for y in unknown for x in y.split('=')]

    settings = cameras[id] + "_" + str(id) + ".settings"
    settings = settings.replace(" ", "_")

    logging.info("args.commad: " + args.command + " unknown: " +
                 repr(unknown) + " settings " + settings)

    # The rest of 'unknown' should be name/value pairs.

    if args.command == 'info':
        info(camera)
    elif args.command == 'exposure':
        capture(camera, settings,
                [ 'number', '1', 'adjust', 'true', 'histogram', 'true' ] +
                unknown)
    elif args.command == 'focus':
        focus(camera, settings, unknown)
    elif args.command == 'capture':
        capture(camera, settings, unknown)
    else:
        logging.error("Unknown command: " + command)
        sys.exit(1)

    logging.info('Done!')
    sys.exit(0)

if __name__ == "__main__":
    main(sys.argv[1:])
