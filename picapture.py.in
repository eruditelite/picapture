#!/usr/bin/env python3

import argparse, logging, os, re, sys, threading, time
import zwoasi as asi

__author__ = "John Jacques"
__version__ = __VERSION__
__license__ = 'MIT'

################################################################################
## Functions for Modular Use
################################################################################

def script_info():
    print("--> " + os.path.basename(__file__) +
          " version is {:s}".format(__version__))
    if os.path.isfile("/etc/os-release"):
        osrf = open("/etc/os-release", "rt")
        distribution = re.search("NAME=(.*)", osrf.read()).group(1)[1:-1]
        osrf.seek(0)
        version = re.search("VERSION_ID=(.*)", osrf.read()).group(1)[1:-1]
        osrf.close()
        print("--> running on " + distribution + ":" + version)
    else:
        print("--> running on something unknown (TODO: find out)")

################################################################################
## Information
################################################################################

def info(camera):
    info = camera.get_camera_property()
    print('#### Info for %s ####\n' % (info['Name']))
    for name in info.keys():
        if name == 'Name':
            continue
        print('    %s:%s' % (name, info[name]))
    controls = camera.get_controls()
    for name in sorted(controls.keys()):
        print('\n    [%s/%s]' % (name, controls[name]['ControlType']))
        for key in sorted(controls[name].keys()):
            if key == 'Name' or key == 'ControlType':
                continue
            print('        %s: %s' % (key, repr(controls[name][key])))

################################################################################
## Focus
##
## The idea is to start a web server that displays the latest image
## captured (using video capture) until SIGINT.
################################################################################

focused = False

def focus_capture(camera, options):
    global focused
    info = camera.get_camera_property()
    logging.debug("Starting the capture thread! %s with %s" %
                  (info['Name'], options))
    while focused == False:
        print("capturing... focused is " + str(focused) +
              " options are " + str(options[:]))
        time.sleep(1)

def focus(camera, options):
    global focused
    print('focus(' + str(options[:]) + ')')
    try:
        focus_capture_thread = threading.Thread(target=focus_capture,
                                                args=(camera, options))
        focus_capture_thread.start()
        while True:
            time.sleep(100000)
    except KeyboardInterrupt:
        focused = True
    focus_capture_thread.join()

################################################################################
## capturing
################################################################################

def save_capture_settings(filename, controls):
    with open(filename, 'w') as f:
        for k in sorted(controls.keys()):
            f.write('%s=%s\n' % (k, str(controls[k])))

def capture(camera, options):
    info = camera.get_camera_property()
    controls = camera.get_controls()
    logging.debug("capture(): Using %s, options are %s." %
                  (info['Name'], str(options[:])))

    # Process Arguments #
    #####################
    it = iter(options)
    for name in it:
        value = next(it)
        logging.debug("capture(): Processing %s %s" % (name, value))
        if name == 'output':
            filename = value
        elif name == 'number':
            number = int(value);
        elif name == 'exposure':
            if (int(value) > controls['Exposure']['MaxValue'] or
                int(value) < controls['Exposure']['MinValue']):
                raise ValueError("exposure out of range!")
            camera.set_control_value(asi.ASI_EXPOSURE, int(value))

    if 'filename' not in locals() or filename == "":
        raise ValueError("output MUST be specified!")

    # Capture! #
    ############
    camera.set_control_value(asi.ASI_BANDWIDTHOVERLOAD,
                             controls['BandWidth']['MinValue'])
    camera.disable_dark_subtract()
    camera.stop_video_capture()
    camera.stop_exposure()
    camera.set_image_type(asi.ASI_IMG_RGB24)

    if 'number' not in locals() or number == 1:
        camera.capture(filename=filename)
        save_capture_settings(filename + ".info", camera.get_control_values())
    else:
        for i in range(0, number, 1):
            name = filename.split('.')
            print(name)
            name = name[0] + str(i).zfill(len(str(number))) + "." + name[1]
            print(name)
            camera.capture(filename=name)
            save_capture_settings(name + ".info", camera.get_control_values())

################################################################################
## When Used as a Script
################################################################################

def main(argv):
    # parse arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('--loglevel', help="logger level",
                        choices=['DEBUG', 'INFO', 'WARNING',
                                 'ERROR', 'CRITICAL'], type=str.upper)
    parser.add_argument("--logfile", help="file for logger output")
    parser.add_argument('-v', '--version', help="display the version", action="store_true")
    parser.add_argument('-c', '--command', help="what to do...", choices = ['list', 'info', 'focus', 'capture'], default="list")
    args, unknown = parser.parse_known_args()

    # set up the logger
    if args.loglevel:
        loglevel = getattr(logging, args.loglevel)
    else:
        loglevel = logging.root.level

    logging.basicConfig(level=loglevel,
                        format='%(filename)s - %(levelname)s - %(message)s')

    if args.logfile:
        logging.getLogger().addHandler(logging.FileHandler(args.logfile))

    if args.version:
        script_info()

    asilib = os.getenv('ZWO_ASI_LIB')

    if asilib:
        asi.init(asilib)
    else:
        logging.error("ZWO_ASI_LIB must be the full path to libASICamera2.so!")
        sys.exit(1)

    num_cameras = asi.get_num_cameras()

    if num_cameras == 0:
        logging.error("No Cameras Found")
        sys.exit(1)
    else:
        logging.info("Cameras Found: " + str(num_cameras))

    cameras = asi.list_cameras()

    if args.command == 'list':
        for i in range(num_cameras):
            print('%d : %s' % (i, cameras[i]))
        sys.exit(0)

    id = int(unknown[0])
    if id < num_cameras:
        camera = asi.Camera(id)
    else:
        logging.error('Invalid Camera ID')
        sys.exit(1)

    unknown.pop(0)
    unknown = [x for y in unknown for x in y.split('=')]

    # The rest of 'unknown' should be name/value pairs.

    if args.command == 'info':
        info(camera)
    elif args.command == 'focus':
        focus(camera, unknown)
    elif args.command == 'capture':
        capture(camera, unknown)
    else:
        logging.error("Unknown command: " + command)
        sys.exit(1)

    logging.info('Done!')
    sys.exit(0)

if __name__ == "__main__":
    main(sys.argv[1:])
