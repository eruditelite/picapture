#!/usr/bin/env python3

import argparse, logging, os, pickle, re, sys, tempfile, threading, time, zwoasi

from http import server
from io import BytesIO
from queue import Queue

__author__ = "John Jacques"
__version__ = __VERSION__
__license__ = 'MIT'

################################################################################
## Functions for Modular Use
################################################################################

def script_info():
    print("--> " + os.path.basename(__file__) +
          " version is {:s}".format(__version__))
    if os.path.isfile("/etc/os-release"):
        osrf = open("/etc/os-release", "rt")
        distribution = re.search("NAME=(.*)", osrf.read()).group(1)[1:-1]
        osrf.seek(0)
        version = re.search("VERSION_ID=(.*)", osrf.read()).group(1)[1:-1]
        osrf.close()
        print("--> running on " + distribution + ":" + version)
    else:
        print("--> running on something unknown (TODO: find out)")

def set_controls_to_default(camera):
    controls = camera.get_controls()
    for name in controls.keys():
        camera.set_control_value(int(controls[name]['ControlType']),
                                 int(repr(controls[name]['DefaultValue'])))

def load_controls(camera, filename):
    controls = camera.get_controls()
    fp = open(filename, "rb")
    settings = pickle.load(fp)
    for name in controls.keys():
        camera.set_control_value(int(controls[name]['ControlType']),
                                 int(repr(settings[name])))
    fp.close()

def save_controls(camera, filename):
    settings = camera.get_control_values()
    fp = open(filename, "wb")
    pickle.dump(settings, fp)
    fp.close()

def save_capture_settings(camera, filename):
    settings = camera.get_control_values()
    fp = open(filename, "w")
    for k in sorted(settings.keys()):
        fp.write('%s=%s\n' % (k, str(settings[k])))
    fp.close()

def save_capture(camera, filename):
    controls = camera.get_controls()
    camera.set_control_value(zwoasi.ASI_BANDWIDTHOVERLOAD,
                             controls['BandWidth']['MinValue'])
    camera.disable_dark_subtract()
    camera.stop_video_capture()
    camera.stop_exposure()
    camera.set_image_type(zwoasi.ASI_IMG_RGB24)
    camera.capture(filename=filename)

################################################################################
## Information
################################################################################

def info(camera):
    info = camera.get_camera_property()
    print('#### Info for %s ####\n' % (info['Name']))
    for name in info.keys():
        if name == 'Name':
            continue
        print('    %s:%s' % (name, info[name]))

    controls = camera.get_controls()
    settings = camera.get_control_values()
    for name in sorted(controls.keys()):
        print('\n    [%s/%s/%s]' %
              (name, controls[name]['ControlType'], settings[name]))
        for key in sorted(controls[name].keys()):
            if key == 'Name' or key == 'ControlType':
                continue
            print('        %s: %s' % (key, repr(controls[name][key])))

################################################################################
## Focus
##
## The idea is to start a web server that displays the latest image
## captured (using video capture) until SIGINT.
################################################################################

focused = False

## Capture an Image and Put it in the Queue! ##
###############################################

def focus_capture(camera, settings, queue):
    global focused
    info = camera.get_camera_property()
    controls = camera.get_controls()
    logging.debug("Starting the capture thread! %s to %s" %
                  (info['Name'], str(queue)))
    set_controls_to_default(camera) # Start with the defaults!
    if os.path.exists(settings):
        load_controls(camera, settings)

    temp_dir = tempfile.TemporaryDirectory()

    while focused == False:
        filename = temp_dir.name + "/latest_capture.png"
        save_capture(camera, filename)
        fp = open(filename, "rb")
        buffer = BytesIO(fp.read())
        queue.put(buffer)
        time.sleep(0.5)

    temp_dir.cleanup()

## Use SimpleHTTPServer to "Serve" the Image ##
###############################################



def focus_stream(queue):
    global focused
    logging.debug("Starting the streaming thread!")

    temp_dir = tempfile.TemporaryDirectory()

    while focused == False:
        if not queue.empty():
            buffer = queue.get()
            fp = open(temp_dir.name + "/latest.png", "wb")
            fp.write(buffer.getbuffer())
        time.sleep(0.05)

def focus(camera, settings, options):
    global focused
    print('focus(' + str(options[:]) + ')')

    queue = Queue(maxsize=10)

    try:
        streaming_thread = threading.Thread(target=focus_stream, args=(queue,))
        streaming_thread.start()
        capture_thread = threading.Thread(target=focus_capture,
                                          args=(camera, settings, queue))
        capture_thread.start()
        while True:
            time.sleep(100000)
    except KeyboardInterrupt:
        focused = True

    capture_thread.join()
    streaming_thread.join()

################################################################################
## Capture
################################################################################

def capture(camera, settings, options):
    info = camera.get_camera_property()
    controls = camera.get_controls()
    logging.debug("capture(): Using %s, options are %s." %
                  (info['Name'], str(options[:])))
    set_controls_to_default(camera) # Start with the defaults!
    if os.path.exists(settings):
        load_controls(camera, settings)

    # Process Arguments #
    #####################
    it = iter(options)
    for name in it:
        value = next(it)
        logging.debug("capture(): Processing %s %s" % (name, value))
        if name == 'output':
            filename = value
        elif name == 'number':
            number = int(value);
        elif name == 'exposure':
            if (int(value) > controls['Exposure']['MaxValue'] or
                int(value) < controls['Exposure']['MinValue']):
                raise ValueError("exposure out of range!")
            camera.set_control_value(zwoasi.ASI_EXPOSURE, int(value))

    if 'filename' not in locals() or filename == "":
        raise ValueError("output MUST be specified!")

    save_controls(camera, settings)

    # Capture! #
    ############

    if 'number' not in locals() or number == 1:
        save_capture(camera, filename)
        save_capture_settings(camera, filename + ".info")
    else:
        for i in range(0, number, 1):
            name = filename.split('.')
            name = name[0] + str(i).zfill(len(str(number))) + "." + name[1]
            save_capture(camera, name)
        name = filename.split('.')
        name = name[0] + 'N' * len(str(number)) + '.' + name[1] + '.info'
        save_capture_settings(camera, name)

################################################################################
## When used as a script...
################################################################################

def main(argv):
    # parse arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('--loglevel', help="logger level",
                        choices=['DEBUG', 'INFO', 'WARNING',
                                 'ERROR', 'CRITICAL'], type=str.upper)
    parser.add_argument("--logfile", help="file for logger output")
    parser.add_argument('-v', '--version', help="display the version", action="store_true")
    parser.add_argument('-c', '--command', help="what to do...", choices = ['list', 'info', 'focus', 'capture'], default="list")
    args, unknown = parser.parse_known_args()

    # set up the logger
    if args.loglevel:
        loglevel = getattr(logging, args.loglevel)
    else:
        loglevel = logging.root.level

    logging.basicConfig(level=loglevel,
                        format='%(filename)s - %(levelname)s - %(message)s')

    if args.logfile:
        logging.getLogger().addHandler(logging.FileHandler(args.logfile))

    if args.version:
        script_info()

    asilib = os.getenv('ZWO_ASI_LIB')

    if asilib:
        zwoasi.init(asilib)
    else:
        logging.error("ZWO_ASI_LIB must be the full path to libASICamera2.so!")
        sys.exit(1)

    num_cameras = zwoasi.get_num_cameras()

    if num_cameras == 0:
        logging.error("No Cameras Found")
        sys.exit(1)
    else:
        logging.info("Cameras Found: " + str(num_cameras))

    cameras = zwoasi.list_cameras()

    if args.command == 'list':
        for i in range(num_cameras):
            print('%d : %s' % (i, cameras[i]))
        sys.exit(0)

    id = int(unknown[0])
    if id < num_cameras:
        camera = zwoasi.Camera(id)
    else:
        logging.error('Invalid Camera ID')
        sys.exit(1)

    unknown.pop(0)
    unknown = [x for y in unknown for x in y.split('=')]

    settings = cameras[id] + "_" + str(id) + ".settings"
    settings = settings.replace(" ", "_")

    # The rest of 'unknown' should be name/value pairs.

    if args.command == 'info':
        info(camera)
    elif args.command == 'focus':
        focus(camera, settings, unknown)
    elif args.command == 'capture':
        capture(camera, settings, unknown)
    else:
        logging.error("Unknown command: " + command)
        sys.exit(1)

    logging.info('Done!')
    sys.exit(0)

if __name__ == "__main__":
    main(sys.argv[1:])
